<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-120456720-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <title>Kelvin.Liang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="A blog dedicated to computer science techniques">
<meta name="keywords" content="Machine Learning, Blockchain, Math, Operating System, C++, Python, Software Engineering">
<meta property="og:type" content="website">
<meta property="og:title" content="Kelvin.Liang">
<meta property="og:url" content="http://kelvin.ink/page/2/index.html">
<meta property="og:site_name" content="Kelvin.Liang">
<meta property="og:description" content="A blog dedicated to computer science techniques">
<meta property="og:locale" content="En, ZH">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kelvin.Liang">
<meta name="twitter:description" content="A blog dedicated to computer science techniques">
  
    <link rel="alternate" href="/atom.xml" title="Kelvin.Liang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Kelvin.Liang</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">ziyoustep@gmail.com</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://kelvin.ink"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-DM_Note1" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/20/DM_Note1/" class="article-date">
  <time datetime="2018-10-20T09:45:55.000Z" itemprop="datePublished">2018-10-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/20/DM_Note1/">DataMing Note 1 Data Mining Basics</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>This note is going to explain some basic concepts of data mining. After reading it, you should be able to answer these questions:</p>
<ul>
<li>What’s data mining?<br>–&gt; Section[What’s Data Mining]</li>
<li>How to do data mining step by step?<br>–&gt; Section[KDD Process]</li>
<li>How’s the architecture of data mining system looks like?<br>–&gt; Section[Architecture of Data Mining System]</li>
<li>What algorithms can we apply to search for the pattern(model) that we want?<br>–&gt; Section[What do we do in each part of KDD process]</li>
</ul>
<h1 id="What’s-Data-Mining"><a href="#What’s-Data-Mining" class="headerlink" title="What’s Data Mining"></a>What’s Data Mining</h1><p>Data mining helps us to extract useful information from large databases. It’s <strong>a step</strong> within the KDD process.</p>
<p><strong>Definition:</strong> <strong>Knowledge discovery in database(KDD)</strong> is the process of finding useful information and knowledge in data.</p>
<p><strong>Definition:</strong> <strong>Data mining</strong> is the use of algorithms to extract patterns or models in KDD process.</p>
<h1 id="KDD-Process"><a href="#KDD-Process" class="headerlink" title="KDD Process"></a>KDD Process</h1><p>There are totally six steps in KDD process as is shown on below:<br><img src="/resources/res/DM_Note1/KDD_Parts.png" alt="Steps of KDD" width="90%"><br>The KDD process can be divided into three parts. The first part is data preprocessing including step 1-3. The second part is data mining where many data mining algorithms involve. And the last part is evaluation and presentation. We will be mainly focus on the first and second parts in our data mining notes.</p>
<p>The following figures illustrates the overall KDD process in more details:<br><img src="/resources/res/DM_Note1/KDD_Process.png" alt="KDD Process" width="90%"></p>
<p><img src="/resources/res/DM_Note1/KDD_Process_with_parts.png" alt="KDD Process in Parts" width="90%"></p>
<p>Bear in mind that KDD process is extremely important for your study of data mining. Your get to know what you are doing from KDD points of view at each steps. Always ask yourself why the techniques that you are studying helps for a better result.</p>
<h1 id="Architecture-of-Data-Mining-System"><a href="#Architecture-of-Data-Mining-System" class="headerlink" title="Architecture of Data Mining System"></a>Architecture of Data Mining System</h1><p>Here is the architecture of data mining system:<br><img src="/resources/res/DM_Note1/ArchitectureofDataMiningSystem.png" alt="Architecture of Data Mining System" width="90%"></p>
<h1 id="What-do-we-do-in-each-part-of-KDD-process"><a href="#What-do-we-do-in-each-part-of-KDD-process" class="headerlink" title="What do we do in each part of KDD process"></a>What do we do in each part of KDD process</h1><h2 id="Data-Preprocessing"><a href="#Data-Preprocessing" class="headerlink" title="Data Preprocessing"></a>Data Preprocessing</h2><p><img src="/resources/res/DM_Note1/DataPreprocessing.png" alt="Data Preprocessing" width="90%"></p>
<h2 id="Data-Mining"><a href="#Data-Mining" class="headerlink" title="Data Mining"></a>Data Mining</h2><p><img src="/resources/res/DM_Note1/DataMining.png" alt="Data Mining" width="90%"></p>
<h2 id="Evaluation-and-Presentation"><a href="#Evaluation-and-Presentation" class="headerlink" title="Evaluation and Presentation"></a>Evaluation and Presentation</h2><p>Not addressed in this note at this time.</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>This notes briefly introduces the KDD process and data mining system architecture. In later notes we will illustrate data preprocessing and data mining algorithms in more details, if you are interested in them, please refer to <a href="kelvin.ink">kelvin.ink</a> for more details.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kelvin.ink/2018/10/20/DM_Note1/" data-id="cjya47p0c0004kx0zadfg3oai" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Mining/">Data Mining</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-UniprocessorSchedulingAlgorithm" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/14/UniprocessorSchedulingAlgorithm/" class="article-date">
  <time datetime="2018-10-14T09:19:44.000Z" itemprop="datePublished">2018-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/14/UniprocessorSchedulingAlgorithm/">Uniprocessor Scheduling Algorithms</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Your may download all of the tables(key points) of this article by clicking this link:<br>PDF Quick Reference:<br><a href="/resources/res/UniprocessorSchedulingAlgorithm/UniprocessorSchedulingAlgorithmsTables.pdf">Download tables</a></p>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>In this article, we are going to introduce several short-term scheduling algorithms that are widely used in uniprocessor computers. After reading this article, your should be able to answer the following questions: What’s process state? What’s short-term scheduling? When to do short-term scheduling? What kinds of scheduling algorithms do we currently have? How do we choose a scheduling algorithm and based on what criteria? The following table indicates which sections in this article are trying to answer these questions correspondingly.<br><img src="/resources/res/UniprocessorSchedulingAlgorithm/TableOfContents.png" alt="Contents Indicating Table" width="70%"></p>
<h1 id="Process-States"><a href="#Process-States" class="headerlink" title="Process States"></a>Process States</h1><ul>
<li><strong>New</strong>: A process is created.<br>  Program code are moved from disk to main memory.</li>
<li><strong>Ready</strong>: The process is waiting to be scheduling to a processor.<br>  Program code reside in main memory.</li>
<li><strong>Running</strong>: Instructions are being executed in CPU.<br>  Instructions reside in CPU.</li>
<li><strong>Waiting</strong>: The process is blocked and waiting for some events to occur(signal)<br>  Program code are in main memory or has been swapped out to virtual memory.</li>
<li><strong>Terminated</strong>: The process has finished execution.<br>  Program code are removed from memory.</li>
</ul>
<p>This is the state transition diagram of the process states.<br><img src="/resources/res/UniprocessorSchedulingAlgorithm/StateTransitionDiagram.png" alt="State Transition Diagram" width="70%"></p>
<p>The table below shows where do program code mainly reside at each state.<br><img src="/resources/res/UniprocessorSchedulingAlgorithm/ProgramCodeReside.png" alt="Program Code Location" width="70%"></p>
<h1 id="Types-of-Scheduling"><a href="#Types-of-Scheduling" class="headerlink" title="Types of Scheduling"></a>Types of Scheduling</h1><p>There are three kinds of scheduling including <code>long-term scheduling</code> , <code>medium-term scheduling</code> and <code>short-term scheduling</code>. This article is mainly focus on short-term scheduling.</p>
<p>This table shows when do we do the three scheduling in terms of state transitions.<br><img src="/resources/res/UniprocessorSchedulingAlgorithm/SchedulingAndStateTransition1.png" alt="Scheduling and State Transition" width="70%"></p>
<p>We mark them on the state transition diagram:<br><img src="/resources/res/UniprocessorSchedulingAlgorithm/SchedulingAndStateTransition2.png" alt="Scheduling on State Transition" width="70%"></p>
<h1 id="Short-Term-Scheduling"><a href="#Short-Term-Scheduling" class="headerlink" title="Short-Term Scheduling"></a>Short-Term Scheduling</h1><h2 id="Scheduling-Criteria"><a href="#Scheduling-Criteria" class="headerlink" title="Scheduling Criteria"></a>Scheduling Criteria</h2><p>There are a bunch of scheduling criteria that we need to consider when choosing a scheduling algorithm.</p>
<ul>
<li>CPU utilization (u%)</li>
<li>Throughput (process/second)</li>
<li>Turnaround time (seconds/process)</li>
<li>Waiting time (seconds)</li>
<li>Response time (seconds)</li>
<li>Deadline</li>
<li>Fairness</li>
<li>Predictability</li>
<li>Policy enforcement</li>
<li>Balance</li>
</ul>
<h2 id="Criteria-for-Different-Systems"><a href="#Criteria-for-Different-Systems" class="headerlink" title="Criteria for Different Systems"></a>Criteria for Different Systems</h2><p>Different systems should follow different criteria based on their own requirements.<br><img src="/resources/res/UniprocessorSchedulingAlgorithm/CriteriasforDifferentSystems.png" alt="Criteria for Different Systems" width="70%"></p>
<h2 id="Scheduling-Algorithms"><a href="#Scheduling-Algorithms" class="headerlink" title="Scheduling Algorithms"></a>Scheduling Algorithms</h2><p>We will introduce four scheduling algorithms with examples. In next section, we will explain the details of these algorithms.</p>
<h3 id="1-First-Come-First-Serve-FCFS"><a href="#1-First-Come-First-Serve-FCFS" class="headerlink" title="1. First-Come-First-Serve (FCFS)"></a>1. First-Come-First-Serve (FCFS)</h3><p><strong>Selection Function:</strong> Select the process with the minimum arrival time. (Non-preemptive)<br><strong>Example for FCFS:</strong><br>Suppose there are four processes whose arrival time and service time are listed in the table.<br><img src="/resources/res/UniprocessorSchedulingAlgorithm/FCFS_table.png" alt="FCFS Processes Table" width="70%"><br>The scheduling result in Gantt chart:<br><img src="/resources/res/UniprocessorSchedulingAlgorithm/FCFS_scheduling.png" alt="FCFS Scheduling Result" width="50%"></p>
<h3 id="2-Round-Robin-RR"><a href="#2-Round-Robin-RR" class="headerlink" title="2. Round-Robin (RR)"></a>2. Round-Robin (RR)</h3><p><strong>Selection Function:</strong> Each process execute for fixed length of time quantum. (Preemptive)<br><strong>Example for RR:</strong><br>Suppose there are four processes whose arrival time and service time are listed in the table.<br><img src="/resources/res/UniprocessorSchedulingAlgorithm/RR_table.png" alt="Round-Robin Processes Table" width="70%"><br>The scheduling result in Gantt chart:<br><img src="/resources/res/UniprocessorSchedulingAlgorithm/RR_scheduling.png" alt="Round-Robin Scheduling Result" width="70%"></p>
<h3 id="3-Shortest-Job-First-SJF"><a href="#3-Shortest-Job-First-SJF" class="headerlink" title="3. Shortest-Job-First (SJF)"></a>3. Shortest-Job-First (SJF)</h3><p><strong>Selection Function:</strong> Select the process with the minimum service time (Non-preemptive)<br><strong>Example for SJF:</strong><br>Suppose there are four processes whose arrival time and service time are listed in the table.<br><img src="/resources/res/UniprocessorSchedulingAlgorithm/SJF_table.png" alt="SJF Processes Table" width="70%"><br>The scheduling result in Gantt chart:<br><img src="/resources/res/UniprocessorSchedulingAlgorithm/SJF_scheduling.png" alt="SJF Scheduling Result" width="50%"></p>
<h3 id="4-Preemptive-Shortest-Job-First-PSJF"><a href="#4-Preemptive-Shortest-Job-First-PSJF" class="headerlink" title="4. Preemptive-Shortest-Job-First (PSJF)"></a>4. Preemptive-Shortest-Job-First (PSJF)</h3><p><strong>Selection Function:</strong> Select the process with the minimum <strong>remaining</strong> service time (Preemptive)<br><strong>Example for PSJF:</strong><br>Suppose there are three processes whose arrival time and service time are listed in the table.<br><img src="/resources/res/UniprocessorSchedulingAlgorithm/PSJF_table.png" alt="PSJF Processes Table" width="70%"><br>The scheduling result in Gantt chart:<br><img src="/resources/res/UniprocessorSchedulingAlgorithm/PSJF_scheduling.png" alt="PSJF Scheduling Result" width="50%"></p>
<h2 id="Scheduling-Algorithm-Properties"><a href="#Scheduling-Algorithm-Properties" class="headerlink" title="Scheduling Algorithm Properties"></a>Scheduling Algorithm Properties</h2><p>We define some terms first.</p>
<ul>
<li><strong>a</strong> : arrival time of a process</li>
<li><strong>e</strong> : time spent in execution so far</li>
<li><strong>s</strong> : total service time required by the process, including e</li>
</ul>
<p>The following table shows the corresponding properties to the scheduling algorithms.<br><img src="/resources/res/UniprocessorSchedulingAlgorithm/SchedulingAlgorithmProperties.png" alt="Scheduling Algorithm Properties" width="75%"></p>
<h2 id="Scheduling-Algorithm-Selection"><a href="#Scheduling-Algorithm-Selection" class="headerlink" title="Scheduling Algorithm Selection"></a>Scheduling Algorithm Selection</h2><p>Based on the criteria for different systems and scheduling algorithm properties, we can decide what kind of algorithms we should choose for each kind of systems. As is shown from below:<br><img src="/resources/res/UniprocessorSchedulingAlgorithm/SystemsAndCorrespondingAlgorithm.png" alt="Systems and Scheduling Algorithms" width="70%"></p>
<h1 id="Why-Why-Why"><a href="#Why-Why-Why" class="headerlink" title="Why Why Why"></a>Why Why Why</h1><h2 id="Why-Multiprograming"><a href="#Why-Multiprograming" class="headerlink" title="Why Multiprograming"></a>Why Multiprograming</h2><p>Some processes are <strong>CPU bound</strong>, and some are <strong>I/O bound</strong>. An I/O bound process will be blocked when it tries to do I/O. <strong>To improve CPU utilization rate</strong>, engineers proposed the concept of Multiprograming. That is to say — we load many processes into the main memory at the same time. When a running process is blocked by I/O operation, we switch to run other processes. Multiprograming is the root cause that we need to do short-term scheduling.</p>
<h2 id="What’s-the-differences-between-Multiprograming-and-Multithreading"><a href="#What’s-the-differences-between-Multiprograming-and-Multithreading" class="headerlink" title="What’s the differences between Multiprograming and Multithreading"></a>What’s the differences between Multiprograming and Multithreading</h2><p>Multiprograming is for improving CPU utilization, while Multithreading is for many other reasons. For example: share resources, parallelism, simplify code structure, improve concurrency and many others.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kelvin.ink/2018/10/14/UniprocessorSchedulingAlgorithm/" data-id="cjya47p120013kx0zj9y5jlf7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Operating-System/">Operating System</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HowToReadABook_zh" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/09/HowToReadABook_zh/" class="article-date">
  <time datetime="2018-10-09T04:34:34.000Z" itemprop="datePublished">2018-10-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/09/HowToReadABook_zh/">如何阅读数学著作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文出自<a href="kelvin.ink">kelvin.ink</a>转载请注明出处<br>Email: <a href="mailto:ziyoustep@gmail.com" target="_blank" rel="noopener">ziyoustep@gmail.com</a><br>欢迎与感谢一切指正</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文的主体内容将会介绍系统地阅读一本数学著作的方法。文章内容主要来源于笔者个人的求学经验，导师的指导，以及《如何阅读一本书》(How to read a book)的启发。《如何阅读一本书》真的是一本不可多得的好书，由 <em>Mortimer Adler</em> 与 <em>Charles Van Doren</em> 于1972年再版。它由浅入深介绍了阅读一本书的基本原则并把阅读分为有梯度的四个层次，明确每个层次的阅读应该达成什么样的效果。非常建议每个家庭的书架上都拥有一本这样的书。再次向两位老先生致敬。本文的内容将会有小部分与《如何阅读一本书》重复，原因是笔者的体验与书上叙述非常类似，例如我们对于“数学是一门语言”的见解是如此的一致。整篇文章的讨论都是建立在“公理化系统”这个关键概念上面，然后我们会依照这个关键概念提出阅读数学著作的基本原则。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>数学是一门语言。</strong>或许你不同意我的论断，但是你可以暂时先接受我的观点。语言的组成有文字，读音，使用这些文字我们就可以表达我们的思想。数学既然是一门语言，数学符号(mathmatics symbol)就是它的文字，而各种命题(proposition)就是其所要表达的思想。例如：《几何原本》中命题19为–在任何三角形中大角对大边。在这个命题中，<code>三角形</code> ，<code>角</code> ，<code>边</code> 等都是数学符号，因为他们都有相应的数学定义，代表不同的数学含义。整个命题构成了一组完整的的语义：在三角形中，角大的，其对应的边也相对比较大。整个数学领域都是在做着一模一样的事情–用规范的数学语言来表达我们所发现的某些真理。而我们要理解数学的内部逻辑就必须先理解这些数学符号，然后再理解每个命题的含义，以及命题与命题间的关系。说到命题与命题间的关系，我们就需要介绍公理化系统(Axiomatic system)。这个概念首次由欧几里得于公元前300年左右在《几何原本》(Euclid’s Elements)中提出，是数学史上极其关键的里程碑。《几何原本》使得一些离散的数学结论被连接成整体，成为结构严谨的几何学大厦。接下来的章节我们将会介绍一座数学理论大厦是怎样建成的。在进一步讨论之前我们先对一些数学名词进行简单的定义，更加严格的数学定义请参阅其他数学著作。</p>
<h1 id="数学名词定义"><a href="#数学名词定义" class="headerlink" title="数学名词定义"></a>数学名词定义</h1><ul>
<li><strong>命题(Proposition):</strong> 一个可以被判定为真(true)或假(false)的陈述。</li>
<li><strong>公理(Axiom):</strong> 一个被当作不证自明的命题。</li>
<li><strong>定理(Theorem):</strong> 一个重要的已经被证明为真的命题</li>
<li><strong>引理(Lemma):</strong> 为了证明定理，先证明某些重要结论，这些结论称为引理</li>
<li><strong>推论(Corollary)</strong>: 一个可以由定理简单直接推出的结论</li>
</ul>
<p>总结一下这些数学概念之间的相关关系：</p>
<ol>
<li>公理，定理，引理，推论都是命题</li>
<li>定理的证明可能没有那么直接，我们需要一些辅助性的引理帮助证明；有了定理，我们经常可以马上做一些简单推论</li>
<li>定理和「引理」，「推论」的主要区别是：定理比较有趣，比较有意义，有价值；而其他两者的结论我们可能不太想关心</li>
<li>公理和定理是公理化系统最重要的组成部分</li>
</ol>
<h1 id="公理化系统"><a href="#公理化系统" class="headerlink" title="公理化系统"></a>公理化系统</h1><p>公理化系统最初由欧几里得建立，目的是以一套标准化的流程来建立一个严谨的理论体系。简单而言，公理化系统就是选出一组不证自明的最为基础的公理集，然后以这些公理作为基石证明推导出其他关键定理。由此可以形成一个完备的数学理论体系，例如欧几里得建立的欧氏几何理论。公理化系统有三个重要性质，分别是自洽性(consistent), 独立性(independent), 完备性(complete)。具有这样的性质的公理系统就是好的公理系统。构建公理化系统的第一步就是选取合适的公理，选取公理的时候数学家必须尽量使得这个系统满足这三大性质。虽然在欧几里得之后，数学有了更长足的发展（例如形式公理的建立），但是绝大部分的数学分支依然沿用公理化方法来建立严谨的理论体系。我们依然可以因循这个逻辑来帮助我们的学习。</p>
<p>下图展示了理论大厦的整体架构，先由公理证明一批重要定理，再由已经证明的定理产生更多的定理：<br><img src="/resources/res/HowToReadABook_zh/AxiomaticSystem2.jpg" alt="Theoretical system" width="25%"></p>
<p>下图展示了公理化系统的创建过程。其中黄色的「定义」部分并不是公理化系统的主要内容。它只是在推导新的结论前定义清楚一些关键的数学概念使得所有人对这些关键概念达成共识。其过程已经在前面章节说明过了，就不再重复。<br><img src="/resources/res/HowToReadABook_zh/AxiomaticSystem.jpg" alt="Axiomatic System" width="50%"></p>
<p>接下来我们将会介绍到欧几里得的《几何原本》以及公理化系统的突出贡献：<br>一切的得来并非无缘无故的，而真理也没有显得那么理所当然。《几何原本》的许多定理并非欧几里得原创，在欧几里得之前，就已经有泰勒斯，毕达哥拉斯学派，柏拉图学派等前人付出了艰苦的劳动，给出了许多零零散散的命题。而欧几里得的开创性在于他创造性地建构了公理化系统把这些零散的数学命题统合称为严谨完备的几何理论体系。开创了演绎推理法的先河。<strong>他的天才在于选取了恰当的公理，对于每个关键的数学概念给出了清晰的定义，并且对每个定理都给出了严格的证明</strong>。公理化系统避免了对问题的无限溯因，使得每个定理都有了坚实的理论基础。其中选取恰当的公理是最为艰难的挑战。你没有看错，一直认为理所当然的公理竟然是被选出来的而不是一开始就名正言顺地存在的！想象一下要从成百上千个命题中选出最为基础的公理集，并且要满足公理化系统的约束条件（自洽性，独立性，完备性）是多么困难的过程。欧几里得一共选出来5条公理5条公设，另外包含了119个定义与465个命题(定理)。在现代来看，5条公理和5条公设都是公理，所以一共是10条公理。以此为基石建立了欧氏几何大厦。</p>
<h1 id="基于公理化系统的数学著作阅读方法"><a href="#基于公理化系统的数学著作阅读方法" class="headerlink" title="基于公理化系统的数学著作阅读方法"></a>基于公理化系统的数学著作阅读方法</h1><p>对公理化系统有了整体认识之后我们就开始详细介绍如何阅读数学著作。先提出一条基本原则—<strong>按照建构公理化系统的过程来阅读数学著作</strong>。也就是先理解清楚前提定义，接着阅读公理部分，再阅读引理部分，然后阅读定理部分，最后阅读推论。在这里我们提出两个问题：第一个是为什么这样阅读？第二个是为什么这种方法可行？对于第一个问题，我们的回答是：<strong>我们阅读数学著作的主要目的是要在心中重构这个理论体系</strong>，而这种阅读方式正好可以达到这样的目的。对于第二个问题，我们的回答是：这种方法可行的原因是<strong>绝大部分数学分支的理论体系沿用公理化系统体系</strong>。而一本好的著作也肯定或多或少按照这种方法进行章节安排。实际上有些书不一定会完全按照这样的结构进行安排，这个时候我们采取的方案是自己询问自己正在阅读的是公理化系统的哪一个部分。在阅读的过程中你就能够重构这个系统，如果发现一个定理的证明有不甚明了之处你也可以很快地发现问题的所在。这种方法对于我们来说至关重要，因为当我们在阅读的时候我们至少知道我们是在阅读什么。</p>
<p>前面说到公理与定理是公理化系统最重要的组成成分，而定义部分不是主要内容。这并不表明定义不重要。对于建构理论体系的数学家而言一切都是重要的，包括定义，公理和定理。其中，(1)定义什么？ (2)如何进行定义？ (3)公理的选择？ 以及(4)如何对定理进行证明？ 构成了建构公理化系统的4大问题。而对于一般读者而言，一切成果都已经就绪，我们不需要重复经历这个繁复的过程。这时，对我们而言，最重要的是理解定义，明白作者要讨论的问题。然后，其他的疑惑便能一步步被化解。否则，你将会不知道作者正在谈论什么，他想要为我们呈现一个怎样的结果。</p>
<p>举一个简单又常见的例子：</p>
<hr>
<p><strong>摩尔质量的定义：</strong><br>单位<strong>物质的量</strong>的<strong>物质</strong>所具有的<strong>质量</strong>称摩尔质量（molar mass).<br><strong>英文定义:</strong><br> The <strong>molar mass M</strong> is a physical property defined as the <strong>mass</strong> of a given substance divided by the <strong>amount of substance</strong>.</p>
<hr>
<p>如果你对摩尔质量的定义有疑惑，我敢打赌你肯定对“物质”(substance)，“质量”(mass)，“物质的量”(amount of substance)这三个物理量不清楚或者混淆了。解决的方案是先重新思索一遍这三个量的定义，再回转过来看摩尔质量的定义。接下来的部分我们以此为例讨论当我们在阅读时如何进行逆向倒推(backward chaining)，寻找支撑理论或者解释。</p>
<p>第一步是我们要知道我们正在阅读什么，显然这是一个定义，定义是不需要被证明的，只需要理解它包含了什么关键概念，其涵盖的范围是什么。在阅读这个定义的时候我们要问自己到底对哪些术语名词不了解，然后去了解这些定义。首先“物质的量”的定义是一阿伏伽德罗常数的数量，也就是6.022140857×10<sup>23</sup>。它是数量(quantity)意义，本质上跟一个亿，一个兆这样的量没有区别。接下来“物质”就是我们能接触到的分子原子等一切客观实体。而“质量”相对定义显得稍为复杂，大多数人知道质量却不知道质量的实质定义是什么，通常人们会把它跟重量等同，虽然很多情况下他们都不会因此导致麻烦。然而这是错误的，质量与重量是完全不同的量，人们之所以会犯这样的错误是因为他们没有时常发问自己到底正在阅读什么。现在我们就提出一个问题：到底质量的确切定义是什么？我们单独分一个段落出来讨论什么是质量。</p>
<p>如果我们没有特别指明，一般而言质量就等同于惯性质量。为什么会有这样的区分？因为除了惯性质量还有引力质量。为了避免复杂性，我们避开这些复杂因素，只谈论惯性质量，一般情况下我们只需要知道惯性质量就够了。以下的内容中质量一律等于惯性质量。质量的确切定义是由牛顿第二定律给出，也就是 <code>F = ma</code> ，变换一下就可以得到 <code>m = F/a</code>。牛顿首先定义了什么是<strong>力</strong>，什么是<strong>加速度</strong>，然后才定义质量。可能我们看上去不太直观，仿佛是应该先有质量和加速度，而后有力；仿佛质量这个概念本来自然而然就存在的。然而事实并非如此！虽然我们在日常生活中对于质量有比较直观的感受，拿到重的东西就觉得它的质量很大，轻的东西就觉得它质量小。这种直觉很有价值，它帮助我们理解复杂的自然世界。但是牛顿在建构公理化系统的时候需要考虑更多的问题以满足公理化系统的约束条件（如自洽性，相容性，完备性）。于是他首先定义了<strong>力</strong>和<strong>速度</strong>，然后再导出衍生物理量<strong>加速度</strong>和<strong>质量</strong>。这样做才能使得牛顿三定律建立的经典力学大厦严谨与稳固。</p>
<p>了解了前面三个定义之后，我们很容易就可以明白摩尔质量的定义，我们可以把其定义翻译成如下的句子：</p>
<hr>
<p><strong>摩尔质量</strong> = (单位)(物质的量)的(物质)所具有的(质量)<br><strong>摩尔质量</strong> = (1unit) × (6.022140857×10<sup>23</sup>) (原子或分子) 的 (质量)</p>
<hr>
<p>上面的括号里的内容呈一一对应惯性。如果我们要理解<code>3摩尔碳分子的质量</code>，只需要代入到上面的定义就可以很清楚地了解其涵义了。即：</p>
<hr>
<p><strong>3摩尔碳分子的质量</strong> = (3unit) × (6.022140857×10<sup>23</sup>) (碳分子) 的 (质量)</p>
<hr>
<p>至此我们完结了对这个例子的讨论，我们没有介绍如何阅读定理，不过基本的原则是一致的。在阅读时我们先确定自己阅读的是什么部分(定义？定理？公理？)，然后寻找与它有关的内容(定理或引理)，了解它在整座大厦中担任了什么角色。当我们完成了阅读时我们就能够重构这个体系，并且画出这个体系的树状图，树状图的根就是公理，茎和枝叶就是定理。</p>
<p>总结一下我们在这一节到底谈论了什么。我们阐明了阅读数学著作的核心方向：重构理论系统，并且我们提出了一个指导性的阅读原则：按照建构公理化系统的过程来阅读。最后我们还举了一个例子来说明为什么这样的阅读方式可以帮到我们。</p>
<h1 id="几何原本中的公理化系统"><a href="#几何原本中的公理化系统" class="headerlink" title="几何原本中的公理化系统"></a>几何原本中的公理化系统</h1><p>我们来欣赏一下欧几里得的几何原本的前五页（引自陕西科技出版社2003）：<br><img src="/resources/res/HowToReadABook_zh/EuclidElements1.jpg" alt="Euclid Elements Index"><br><img src="/resources/res/HowToReadABook_zh/EuclidElements2.jpg" alt="Euclid Elements Definition"><br><img src="/resources/res/HowToReadABook_zh/EuclidElements3.jpg" alt="Euclid Elements Definition and Axiom"><br><img src="/resources/res/HowToReadABook_zh/EuclidElements4.jpg" alt="Euclid Elements Axiom and Theorem 1"><br><img src="/resources/res/HowToReadABook_zh/EuclidElements5.jpg" alt="Euclid Elements Poof of Theorem 1"></p>
<p>对于《几何原本》这本书的架构，我们有几点说明。第一是：它是按照公理化系统的架构进行组织的(因为它是开创这种形式的第一本著作)。可以看到，一开始欧几里得给出了一些基本定义，然后给出他的10大公理，然后着手证明他的命题(定理)。注意目录处的命题都是欧几里得要证明的定理。前面已经介绍过，一个命题如果为真，并且非常有趣我们就称之为定理。后面的内容都是提出更多的定义，然后证明更多的定理。我们有第二点要说明：每一个定理的证明必定由前面已经证明的定理或者公理作为支撑。我们可以看第一个命题的证明，由于它是第一个命题，所以它必须只用定义跟公理来证明，仔细看每一步的注释你就会发现的确是遵循这一逻辑。我们要再次强调对读者而言定义的重要性是绝对不能忽视的，你必须清楚你正在探讨的究竟是一个什么样的问题。<br>我们就此结束对于《几何原本》的讨论，下面将会简单讨论一下牛顿的《自然哲学的数学原理》中相似的结构。</p>
<h1 id="自然哲学的数学原理中的公理化系统"><a href="#自然哲学的数学原理中的公理化系统" class="headerlink" title="自然哲学的数学原理中的公理化系统"></a>自然哲学的数学原理中的公理化系统</h1><p>本节我们将不会进行展开讨论，我们只会介绍到牛顿的著作《自然哲学的数学原理》中的确应用到了公理化系统的思想。我们先来看看它的目录(引用自商务印书馆汉译世界学术名著丛书)：<br><img src="/resources/res/HowToReadABook_zh/newtonIndex.jpg" alt="Philosophiæ Naturalis Principia Mathematica Index"><br>可以看到目录中牛顿先洋洋洒洒进行了大量的定义，然后马上开出他的公理，然后下面的部分分章节逐个逐个讨论与证明。一开出公理，牛顿做的第一件事情就是证明一批重要定理（例如平行四边形定则）为后面的讨论提供理论支撑。有兴趣的读者可以自己找来看看，不必把它通读（我也只是粗略看过），只需要欣赏其严密优雅的结构即可。</p>
<p>下面是三大定律(Axiom)的中文版本：<br><img src="/resources/res/HowToReadABook_zh/newtonTheory1.jpg" alt="Philosophiæ Naturalis Principia Mathematica Axiom 1-2"><br><img src="/resources/res/HowToReadABook_zh/newtonTheory2.jpg" alt="Philosophiæ Naturalis Principia Mathematica Axiom 2-3"></p>
<p>可以看到《自然哲学的数学原理》的结构工整而优雅，一本好的数学著作通常都会遵循相似的排版原则。我们都可以应用相似的原则来阅读。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们来总结一下整篇谈论了些什么。我们首先说明了数学是一门语言，这门语言的文字是数学符号；句子是命题，公理，定理等；架构就是公理化系统。然后我们详细说明了什么是公理化系统，并且解释为什么它对于我们来说非常中要。接着我们又提出了阅读数学著作要遵循的基本原则。我们举了两个例子(《几何原本》和《自然哲学的数学原理》)来说明这个原则的确有效。我们就此结束本文的关键讨论，希望能够给你带来一点帮助。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kelvin.ink/2018/10/09/HowToReadABook_zh/" data-id="cjya47p2c001vkx0z8lb9vg23" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Math/">Math</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Interview-Questions/">Interview Questions</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ml-ntu-notes/">Machine Learning NTU Notes</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Blockchain/">Blockchain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Career/">Career</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Mining/">Data Mining</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/">Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Machine-Learning/">Machine Learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Operating-System/">Operating System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Software-Engineering/">Software Engineering</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 15px;">Algorithm</a> <a href="/tags/Blockchain/" style="font-size: 10px;">Blockchain</a> <a href="/tags/Career/" style="font-size: 10px;">Career</a> <a href="/tags/Data-Mining/" style="font-size: 10px;">Data Mining</a> <a href="/tags/Database/" style="font-size: 10px;">Database</a> <a href="/tags/Machine-Learning/" style="font-size: 20px;">Machine Learning</a> <a href="/tags/Math/" style="font-size: 15px;">Math</a> <a href="/tags/Network/" style="font-size: 20px;">Network</a> <a href="/tags/Operating-System/" style="font-size: 15px;">Operating System</a> <a href="/tags/Software-Engineering/" style="font-size: 10px;">Software Engineering</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/18/Interview1/">BST(非平衡),AVL,红黑树,B+树的区别与应用</a>
          </li>
        
          <li>
            <a href="/2019/07/14/HttpIntroduction/">HTTP Introduction</a>
          </li>
        
          <li>
            <a href="/2018/10/27/IPC_and_Synchronization/">Interprocess Communication and Synchronization</a>
          </li>
        
          <li>
            <a href="/2018/10/20/DM_Note1/">DataMing Note 1 Data Mining Basics</a>
          </li>
        
          <li>
            <a href="/2018/10/14/UniprocessorSchedulingAlgorithm/">Uniprocessor Scheduling Algorithms</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Kelvin . Liang<span> @ The University of HongKong</span><br>
      <span>Email: ziyoustep@gmail.com</span> <br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>